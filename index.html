<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <title>小希</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Dancing+Script:wght@700&display=swap');
        body {
            margin: 0;
            overflow: hidden;
            background-color: #f5e6d3;
        }
        #canvas {
            position: fixed;
            top: 0;
            left: 0;
            z-index: 1;
        }
        .valueDisplay {
            display: none;
        }
        .Slider {
            display: none;
        }
        #textDisplay {
            position: absolute;
            padding: 10px 20px;
            font-family: 'Dancing Script', cursive;
            font-size: 38px;
            color: #6b3e30;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.2);
            user-select: none;
            cursor: pointer;
            transition: transform 0.3s ease;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 15px;
            backdrop-filter: blur(5px);
            z-index: 2;
            background: linear-gradient(45deg, #ff69b4, #ffb6c1, #fff);
          -webkit-background-clip: text;
          text-shadow: 2px 2px 4px rgba(255,105,180,0.3),
                      -2px -2px 4px rgba(255,182,193,0.3),
                      0 0 8px rgba(255,255,255,0.5);
          animation: glow 1.5s ease-in-out infinite alternate;
        }
        #textDisplay:hover {
            transform: scale(1.05);
        }
        #hint {
            position: fixed;
            right: 30px;
            bottom: 30px;
            font-family: 'Dancing Script', 'KaiTi', cursive;
            font-size: 28px;
            color: #ff69b4;
            background: rgba(255, 255, 255, 0.9);
            padding: 12px 24px;
            border-radius: 30px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
            animation: float 2.5s ease-in-out infinite;
            z-index: 3;
            transform-origin: center;
            border: 2px solid #ffc0cb;
        }
        @keyframes float {
            0%, 100% { transform: translateY(0) rotate(-3deg); }
            50% { transform: translateY(-15px) rotate(3deg); }
        }
        @keyframes glow {
          from {
            filter: drop-shadow(0 0 2px rgba(255,105,180,0.6));
          }
          to {
            filter: drop-shadow(0 0 8px rgba(255,182,193,0.9));
          }
        }

        /* 新增爱心特效 */
        #textDisplay::after {
          content: "✨";
          position: absolute;
          right: -0.5em;
          top: -0.2em;
          animation: sparkle 1s linear infinite;
        }

        @keyframes sparkle {
          0% { transform: scale(0.8); opacity: 0.8; }
          50% { transform: scale(1.2); opacity: 1; }
          100% { transform: scale(0.8); opacity: 0.8; }
        }
    </style>
</head>
<body>
    <div id="textDisplay">小希妹妹❤幸福常伴</div>
    <div id="hint">可以拖拽哦~</div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.0/p5.js"></script>
    <script>
        let v = [];
        let cols = 600, rows = 30;
        let t_D = 180 * 15 / cols;
        let r_D = 1 / rows;
        let fixedOpening = 8.5;
        let defaultCurve1 = 3;
        let defaultCurve2 = 1.4;

        // 文字动画相关变量
        let textElement;
        let textX = 0;
        let textY = 0;
        let velocityX = 3;
        let velocityY = 2;
        let friction = 0.98;
        let gravity = 0.2;
        let bounce = 0.8;

        let opening, vDensity, pAlign, curve1, curve2;
        let opening_, vDensity_, pAlign_, curve1_, curve2_;
        let canvas;

        function random(min, max) {
            return Math.random() * (max - min) + min;
        }

        function setup() {
            canvas = createCanvas(windowWidth, windowHeight, WEBGL);
            canvas.id('canvas');

            colorMode(HSB);
            angleMode(DEGREES);
            noStroke();

            // 初始化文字位置
            textElement = document.getElementById('textDisplay');
            textX = windowWidth / 2 - textElement.offsetWidth / 2;
            textY = 20;
            updateTextPosition();

            // 开始文字动画
            animateText();

            // Initialize sliders
            opening_ = createDiv();
            opening_.class('valueDisplay');
            opening = createSlider(1, 10, fixedOpening, 0.1);
            opening.class('Slider');

            vDensity_ = createDiv();
            vDensity_.class('valueDisplay');
            vDensity = createSlider(1, 20, 8, 0.1);
            vDensity.class('Slider');

            pAlign_ = createDiv();
            pAlign_.class('valueDisplay');
            pAlign = createSlider(0, 6, 3.6, 0.05);
            pAlign.class('Slider');

            curve1_ = createDiv();
            curve1_.class('valueDisplay');
            curve1 = createSlider(-6, 6, defaultCurve1, 0.1);
            curve1.class('Slider');

            curve2_ = createDiv();
            curve2_.class('valueDisplay');
            curve2 = createSlider(0.5, 1.5, defaultCurve2, 0.1);
            curve2.class('Slider');

            frameRate(60);
        }

        function updateTextPosition() {
            textElement.style.transform = `translate(${textX}px, ${textY}px)`;
        }

        function animateText() {
            textX += velocityX;
            textY += velocityY;

            velocityY += gravity;
            velocityX *= friction;
            velocityY *= friction;

            const maxX = windowWidth - textElement.offsetWidth;
            const maxY = windowHeight - textElement.offsetHeight;

            if (textX <= 0) {
                textX = 0;
                velocityX = Math.abs(velocityX) * bounce;
            } else if (textX >= maxX) {
                textX = maxX;
                velocityX = -Math.abs(velocityX) * bounce;
            }

            if (textY <= 0) {
                textY = 0;
                velocityY = Math.abs(velocityY) * bounce;
            } else if (textY >= maxY) {
                textY = maxY;
                velocityY = -Math.abs(velocityY) * bounce;
            }

            updateTextPosition();
            requestAnimationFrame(animateText);
        }

        function draw() {
            clear();
            orbitControl(4, 4);
            rotateX(-30);

            for (let r = 0; r <= rows; r++) {
                v.push([]);
                for (let theta = 0; theta <= cols; theta++) {
                    let phi = (180 / opening.value()) * Math.exp(-theta * t_D / (vDensity.value() * 180));
                    let petalCut = 1 - (1 / 2) * pow((5 / 4) * pow(1 - ((pAlign.value() * theta * t_D % 360) / 180), 2) - 1 / 4, 2);
                    let hangDown = curve1.value() * pow(r * r_D, 2) * pow(curve2.value() * r * r_D - 1, 2) * sin(phi);

                    let pX = 260 * petalCut * (r * r_D * sin(phi) + hangDown * cos(phi)) * sin(theta * t_D);
                    let pY = -260 * petalCut * (r * r_D * cos(phi) - hangDown * sin(phi));
                    let pZ = 260 * petalCut * (r * r_D * sin(phi) + hangDown * cos(phi)) * cos(theta * t_D);
                    let pos = createVector(pX, pY, pZ);
                    v[r].push(pos);
                }
            }

            for (let r = 0; r < v.length; r++) {
                fill(340, 100, -20 + r * r_D * 120);
                for (let theta = 0; theta < v[r].length; theta++) {
                    if (r < v.length - 1 && theta < v[r].length - 1) {
                        beginShape();
                        vertex(v[r][theta].x, v[r][theta].y, v[r][theta].z);
                        vertex(v[r + 1][theta].x, v[r + 1][theta].y, v[r + 1][theta].z);
                        vertex(v[r + 1][theta + 1].x, v[r + 1][theta + 1].y, v[r + 1][theta + 1].z);
                        vertex(v[r][theta + 1].x, v[r][theta + 1].y, v[r][theta + 1].z);
                        endShape(CLOSE);
                    }
                }
            }

            v = [];
        }

        function windowResized() {
            resizeCanvas(windowWidth, windowHeight);
            const maxX = windowWidth - textElement.offsetWidth;
            const maxY = windowHeight - textElement.offsetHeight;
            textX = constrain(textX, 0, maxX);
            textY = constrain(textY, 0, maxY);
            updateTextPosition();
        }
    </script>
</body>
</html>
