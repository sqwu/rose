<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <title>小希</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Dancing+Script:wght@700&display=swap');
        body {
            margin: 0;
            overflow: hidden;
            background-color: #f5e6d3;
        }
        #canvas {
            position: fixed;
            top: 0;
            left: 0;
            z-index: 1;
        }
        .valueDisplay {
            display: none;
        }
        .Slider {
            display: none;
        }
        #textDisplay {
            position: absolute;
            padding: 10px 20px;
            font-family: 'Dancing Script', cursive;
            font-size: 38px;
            color: #6b3e30;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.2);
            user-select: none;
            cursor: pointer;
            transition: transform 0.3s ease;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 15px;
            backdrop-filter: blur(5px);
            z-index: 2;
        }
        #textDisplay:hover {
            transform: scale(1.05);
        }
        .heart {
            position: absolute;
            pointer-events: none;
            z-index: 2;
            transform-origin: center;
            opacity: 0.8;
        }
    </style>
</head>
<body>
    <div id="textDisplay">小希妹妹❤幸福常伴</div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.0/p5.js"></script>
    <script>
        let v = [];
        let cols = 600, rows = 30;
        let t_D = 180 * 15 / cols;
        let r_D = 1 / rows;
        let fixedOpening = 8.5;
        let defaultCurve1 = 3;
        let defaultCurve2 = 1.4;

        // 文字动画相关变量
        let textElement;
        let textX = 0;
        let textY = 0;
        let velocityX = 3;
        let velocityY = 2;
        let friction = 0.98;
        let gravity = 0.2;
        let bounce = 0.8;

        let opening, vDensity, pAlign, curve1, curve2;
        let opening_, vDensity_, pAlign_, curve1_, curve2_;
        let canvas;

        // 爱心相关变量
        let hearts = [];
        const heartColors = ['#FF69B4', '#FF1493', '#DB7093', '#FFB6C1', '#FFC0CB'];

        class Heart {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.size = random(20, 40);
                this.velocityX = random(-2, 2);
                this.velocityY = random(-8, -4);
                this.rotation = random(-30, 30);
                this.rotationSpeed = random(-2, 2);
                this.opacity = 1;
                this.color = random(heartColors);
                this.element = this.createHeartElement();
                document.body.appendChild(this.element);
            }

            createHeartElement() {
                const heart = document.createElement('div');
                heart.className = 'heart';
                heart.innerHTML = `
                    <svg width="${this.size}" height="${this.size}" viewBox="0 0 24 24" fill="${this.color}">
                        <path d="M12 21.35l-1.45-1.32C5.4 15.36 2 12.28 2 8.5 2 5.42 4.42 3 7.5 3c1.74 0 3.41.81 4.5 2.09C13.09 3.81 14.76 3 16.5 3 19.58 3 22 5.42 22 8.5c0 3.78-3.4 6.86-8.55 11.54L12 21.35z"/>
                    </svg>
                `;
                return heart;
            }

            update() {
                this.velocityY += 0.2;
                this.x += this.velocityX;
                this.y += this.velocityY;
                this.rotation += this.rotationSpeed;
                this.opacity -= 0.008;

                this.element.style.transform = `translate(${this.x}px, ${this.y}px) rotate(${this.rotation}deg)`;
                this.element.style.opacity = this.opacity;

                return this.opacity > 0 && this.y < window.innerHeight;
            }

            remove() {
                this.element.remove();
            }
        }

        function random(min, max) {
            return Math.random() * (max - min) + min;
        }

        function createHeartsAtClick(event) {
            const numHearts = random(5, 8);
            for (let i = 0; i < numHearts; i++) {
                hearts.push(new Heart(event.clientX, event.clientY));
            }
        }

        function updateHearts() {
            hearts = hearts.filter(heart => {
                const alive = heart.update();
                if (!alive) {
                    heart.remove();
                }
                return alive;
            });
            requestAnimationFrame(updateHearts);
        }

        function setup() {
            canvas = createCanvas(windowWidth, windowHeight, WEBGL);
            canvas.id('canvas');

            colorMode(HSB);
            angleMode(DEGREES);
            noStroke();

            // 初始化文字位置
            textElement = document.getElementById('textDisplay');
            textX = windowWidth / 2 - textElement.offsetWidth / 2;
            textY = 20;
            updateTextPosition();

            // 开始文字动画
            animateText();

            // 添加点击监听
            document.addEventListener('click', createHeartsAtClick);

            // 初始化爱心动画
            updateHearts();

            // Initialize sliders
            opening_ = createDiv();
            opening_.class('valueDisplay');
            opening = createSlider(1, 10, fixedOpening, 0.1);
            opening.class('Slider');

            vDensity_ = createDiv();
            vDensity_.class('valueDisplay');
            vDensity = createSlider(1, 20, 8, 0.1);
            vDensity.class('Slider');

            pAlign_ = createDiv();
            pAlign_.class('valueDisplay');
            pAlign = createSlider(0, 6, 3.6, 0.05);
            pAlign.class('Slider');

            curve1_ = createDiv();
            curve1_.class('valueDisplay');
            curve1 = createSlider(-6, 6, defaultCurve1, 0.1);
            curve1.class('Slider');

            curve2_ = createDiv();
            curve2_.class('valueDisplay');
            curve2 = createSlider(0.5, 1.5, defaultCurve2, 0.1);
            curve2.class('Slider');

            frameRate(60);
        }

        function updateTextPosition() {
            textElement.style.transform = `translate(${textX}px, ${textY}px)`;
        }

        function animateText() {
            textX += velocityX;
            textY += velocityY;

            velocityY += gravity;
            velocityX *= friction;
            velocityY *= friction;

            const maxX = windowWidth - textElement.offsetWidth;
            const maxY = windowHeight - textElement.offsetHeight;

            if (textX <= 0) {
                textX = 0;
                velocityX = Math.abs(velocityX) * bounce;
            } else if (textX >= maxX) {
                textX = maxX;
                velocityX = -Math.abs(velocityX) * bounce;
            }

            if (textY <= 0) {
                textY = 0;
                velocityY = Math.abs(velocityY) * bounce;
            } else if (textY >= maxY) {
                textY = maxY;
                velocityY = -Math.abs(velocityY) * bounce;
            }

            updateTextPosition();
            requestAnimationFrame(animateText);
        }

        function draw() {
            clear();
            orbitControl(4, 4);
            rotateX(-30);

            for (let r = 0; r <= rows; r++) {
                v.push([]);
                for (let theta = 0; theta <= cols; theta++) {
                    let phi = (180 / opening.value()) * Math.exp(-theta * t_D / (vDensity.value() * 180));
                    let petalCut = 1 - (1 / 2) * pow((5 / 4) * pow(1 - ((pAlign.value() * theta * t_D % 360) / 180), 2) - 1 / 4, 2);
                    let hangDown = curve1.value() * pow(r * r_D, 2) * pow(curve2.value() * r * r_D - 1, 2) * sin(phi);

                    let pX = 260 * petalCut * (r * r_D * sin(phi) + hangDown * cos(phi)) * sin(theta * t_D);
                    let pY = -260 * petalCut * (r * r_D * cos(phi) - hangDown * sin(phi));
                    let pZ = 260 * petalCut * (r * r_D * sin(phi) + hangDown * cos(phi)) * cos(theta * t_D);
                    let pos = createVector(pX, pY, pZ);
                    v[r].push(pos);
                }
            }

            for (let r = 0; r < v.length; r++) {
                fill(340, 100, -20 + r * r_D * 120);
                for (let theta = 0; theta < v[r].length; theta++) {
                    if (r < v.length - 1 && theta < v[r].length - 1) {
                        beginShape();
                        vertex(v[r][theta].x, v[r][theta].y, v[r][theta].z);
                        vertex(v[r + 1][theta].x, v[r + 1][theta].y, v[r + 1][theta].z);
                        vertex(v[r + 1][theta + 1].x, v[r + 1][theta + 1].y, v[r + 1][theta + 1].z);
                        vertex(v[r][theta + 1].x, v[r][theta + 1].y, v[r][theta + 1].z);
                        endShape(CLOSE);
                    }
                }
            }

            v = [];
        }

        function windowResized() {
            resizeCanvas(windowWidth, windowHeight);
            const maxX = windowWidth - textElement.offsetWidth;
            const maxY = windowHeight - textElement.offsetHeight;
            textX = constrain(textX, 0, maxX);
            textY = constrain(textY, 0, maxY);
            updateTextPosition();
        }
    </script>
</body>
</html>
