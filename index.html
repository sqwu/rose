<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <title>小希</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Dancing+Script:wght@700&display=swap');
        body {
            margin: 0;
            overflow: hidden;
            background-color: #f5e6d3;
            touch-action: none;
        }
        #canvas {
            position: fixed;
            top: 0;
            left: 0;
            z-index: 1;
            touch-action: none;
        }
        .valueDisplay {
            display: none;
        }
        .Slider {
            display: none;
        }
        #textDisplay {
            position: absolute;
            padding: 10px 20px;
            font-family: 'Dancing Script', cursive;
            font-size: 38px;
            color: #6b3e30;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.2);
            user-select: none;
            cursor: pointer;
            transition: transform 0.3s ease;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 15px;
            backdrop-filter: blur(5px);
            z-index: 2;
            background: linear-gradient(45deg, #ff69b4, #ffb6c1, #fff);
            -webkit-background-clip: text;
            text-shadow: 2px 2px 4px rgba(255,105,180,0.3),
                        -2px -2px 4px rgba(255,182,193,0.3),
                        0 0 8px rgba(255,255,255,0.5);
            animation: glow 1.5s ease-in-out infinite alternate;
        }
        
        #hint {
            position: fixed;
            right: 30px;
            bottom: 30px;
            font-family: 'Dancing Script', 'KaiTi', cursive;
            font-size: 28px;
            color: #ff69b4;
            background: rgba(255, 255, 255, 0.9);
            padding: 12px 24px;
            border-radius: 30px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
            animation: float 2.5s ease-in-out infinite;
            z-index: 3;
            transform-origin: center;
            border: 2px solid #ffc0cb;
        }

        .heart {
            position: absolute;
            font-size: 20px;
            color: #ff69b4;
            pointer-events: none;
            z-index: 1;
            opacity: 0;
            animation: float-up 3s ease-out forwards;
        }

        @keyframes float-up {
            0% {
                transform: translateY(0) scale(1);
                opacity: 0;
            }
            20% {
                opacity: 0.8;
            }
            100% {
                transform: translateY(-100vh) scale(0);
                opacity: 0;
            }
        }

        @keyframes float {
            0%, 100% { transform: translateY(0) rotate(-3deg); }
            50% { transform: translateY(-15px) rotate(3deg); }
        }
        @keyframes glow {
            from {
                filter: drop-shadow(0 0 2px rgba(255,105,180,0.6));
            }
            to {
                filter: drop-shadow(0 0 8px rgba(255,182,193,0.9));
            }
        }
    </style>
</head>
<body>
    <div id="textDisplay">小希妹妹❤幸福常伴</div>
    <div id="hint">可以拖拽哦~</div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.0/p5.js"></script>
    <script>
        let v = [];
        let cols = 600, rows = 30;
        let t_D = 180 * 15 / cols;
        let r_D = 1 / rows;
        let fixedOpening = 8.5;
        let defaultCurve1 = 3;
        let defaultCurve2 = 1.4;

        // 文字动画相关变量
        let textElement;
        let textX = 0;
        let textY = 0;
        let velocityX = 3;
        let velocityY = 2;
        let friction = 0.98;
        let gravity = 0.2;
        let bounce = 0.8;

        // 设备方向相关变量
        let beta = 0;
        let gamma = 0;

        // 3D控制相关变量
        let rotationX = -30;
        let rotationY = 0;
        let startX;
        let startY;
        let lastX;
        let lastY;
        let isDragging = false;

        // 玫瑰花缩放因子
        let scaleFactor;

        let opening, vDensity, pAlign, curve1, curve2;
        let opening_, vDensity_, pAlign_, curve1_, curve2_;
        let canvas;

        // 创建随机爱心
        function createHeart() {
            const heart = document.createElement('div');
            heart.className = 'heart';
            heart.innerHTML = '❤';
            heart.style.left = Math.random() * window.innerWidth + 'px';
            heart.style.bottom = '0';
            document.body.appendChild(heart);
            
            // 动画结束后移除元素
            heart.addEventListener('animationend', () => {
                heart.remove();
            });
        }

        // 定期创建爱心
        setInterval(createHeart, 300);

        // 监听设备方向变化
        window.addEventListener('deviceorientation', function(event) {
            beta = event.beta;  // 前后倾斜
            gamma = event.gamma; // 左右倾斜
        });

        function setup() {
            canvas = createCanvas(windowWidth, windowHeight, WEBGL);
            canvas.id('canvas');
            
            // 计算缩放因子
            scaleFactor = min(windowWidth, windowHeight) / 1000;

            let canvasElement = document.getElementById('canvas');
            
            // 鼠标事件监听
            canvasElement.addEventListener('mousedown', handleDragStart);
            canvasElement.addEventListener('mousemove', handleDragMove);
            canvasElement.addEventListener('mouseup', handleDragEnd);
            canvasElement.addEventListener('mouseleave', handleDragEnd);
            
            // 触摸事件监听
            canvasElement.addEventListener('touchstart', handleDragStart);
            canvasElement.addEventListener('touchmove', handleDragMove);
            canvasElement.addEventListener('touchend', handleDragEnd);
            canvasElement.addEventListener('touchcancel', handleDragEnd);

            colorMode(HSB);
            angleMode(DEGREES);
            noStroke();

            textElement = document.getElementById('textDisplay');
            textX = windowWidth / 2 - textElement.offsetWidth / 2;
            textY = 20;
            updateTextPosition();

            animateText();

            opening_ = createDiv();
            opening_.class('valueDisplay');
            opening = createSlider(1, 10, fixedOpening, 0.1);
            opening.class('Slider');

            vDensity_ = createDiv();
            vDensity_.class('valueDisplay');
            vDensity = createSlider(1, 20, 8, 0.1);
            vDensity.class('Slider');

            pAlign_ = createDiv();
            pAlign_.class('valueDisplay');
            pAlign = createSlider(0, 6, 3.6, 0.05);
            pAlign.class('Slider');

            curve1_ = createDiv();
            curve1_.class('valueDisplay');
            curve1 = createSlider(-6, 6, defaultCurve1, 0.1);
            curve1.class('Slider');

            curve2_ = createDiv();
            curve2_.class('valueDisplay');
            curve2 = createSlider(0.5, 1.5, defaultCurve2, 0.1);
            curve2.class('Slider');

            frameRate(60);
        }

        function handleDragStart(event) {
            event.preventDefault();
            
            // 获取点击/触摸位置相对于画布中心的距离
            let x, y;
            if (event.type === 'mousedown') {
                x = event.clientX - windowWidth/2;
                y = event.clientY - windowHeight/2;
            } else if (event.type === 'touchstart') {
                x = event.touches[0].clientX - windowWidth/2;
                y = event.touches[0].clientY - windowHeight/2;
            }
            
            // 扩大交互区域，检查是否在玫瑰花范围内（包括周围区域）
            let distance = sqrt(x*x + y*y);
            if (distance <= 300 * scaleFactor) { // 扩大交互区域
                isDragging = true;
                if (event.type === 'mousedown') {
                    startX = event.clientX;
                    startY = event.clientY;
                    lastX = startX;
                    lastY = startY;
                } else if (event.type === 'touchstart') {
                    startX = event.touches[0].clientX;
                    startY = event.touches[0].clientY;
                    lastX = startX;
                    lastY = startY;
                }
            }
        }

        function handleDragMove(event) {
            event.preventDefault();
            if (!isDragging) return;

            let currentX, currentY;
            
            if (event.type === 'mousemove') {
                currentX = event.clientX;
                currentY = event.clientY;
            } else if (event.type === 'touchmove') {
                currentX = event.touches[0].clientX;
                currentY = event.touches[0].clientY;
            }

            const deltaX = currentX - lastX;
            const deltaY = currentY - lastY;

            rotationY += deltaX * 0.5;
            rotationX += deltaY * 0.5;

            rotationX = constrain(rotationX, -60, 60);

            lastX = currentX;
            lastY = currentY;
        }

        function handleDragEnd(event) {
            isDragging = false;
        }

        function updateTextPosition() {
            // 添加重力感应影响
            if (beta !== null && gamma !== null) {
                velocityX += gamma * 0.1;
                velocityY += beta * 0.1;
            }

            textX += velocityX;
            textY += velocityY;

            velocityY += gravity;
            velocityX *= friction;
            velocityY *= friction;

            const maxX = windowWidth - textElement.offsetWidth;
            const maxY = windowHeight - textElement.offsetHeight;

            if (textX <= 0) {
                textX = 0;
                velocityX = Math.abs(velocityX) * bounce;
            } else if (textX >= maxX) {
                textX = maxX;
                velocityX = -Math.abs(velocityX) * bounce;
            }

            if (textY <= 0) {
                textY = 0;
                velocityY = Math.abs(velocityY) * bounce;
            } else if (textY >= maxY) {
                textY = maxY;
                velocityY = -Math.abs(velocityY) * bounce;
            }

            textElement.style.transform = `translate(${textX}px, ${textY}px)`;
            requestAnimationFrame(animateText);
        }

        function animateText() {
            updateTextPosition();
        }

        function draw() {
            clear();
            
            // 将坐标系移动到画布中心
            translate(0, 0, -200); // 稍微往后移动以获得更好的3D效果
            
            // 应用缩放
            scale(scaleFactor);
            
            // 应用旋转
            rotateX(rotationX);
            rotateY(rotationY);

            for (let r = 0; r <= rows; r++) {
                v.push([]);
                for (let theta = 0; theta <= cols; theta++) {
                    let phi = (180 / opening.value()) * Math.exp(-theta * t_D / (vDensity.value() * 180));
                    let petalCut = 1 - (1 / 2) * pow((5 / 4) * pow(1 - ((pAlign.value() * theta * t_D % 360) / 180), 2) - 1 / 4, 2);
                    let hangDown = curve1.value() * pow(r * r_D, 2) * pow(curve2.value() * r * r_D - 1, 2) * sin(phi);

                    let pX = 260 * petalCut * (r * r_D * sin(phi) + hangDown * cos(phi)) * sin(theta * t_D);
                    let pY = -260 * petalCut * (r * r_D * cos(phi) - hangDown * sin(phi));
                    let pZ = 260 * petalCut * (r * r_D * sin(phi) + hangDown * cos(phi)) * cos(theta * t_D);
                    let pos = createVector(pX, pY, pZ);
                    v[r].push(pos);
                }
            }

            for (let r = 0; r < v.length; r++) {
                fill(340, 100, -20 + r * r_D * 120);
                for (let theta = 0; theta < v[r].length; theta++) {
                    if (r < v.length - 1 && theta < v[r].length - 1) {
                        beginShape();
                        vertex(v[r][theta].x, v[r][theta].y, v[r][theta].z);
                        vertex(v[r + 1][theta].x, v[r + 1][theta].y, v[r + 1][theta].z);
                        vertex(v[r + 1][theta + 1].x, v[r + 1][theta + 1].y, v[r + 1][theta + 1].z);
                        vertex(v[r][theta + 1].x, v[r][theta + 1].y, v[r][theta + 1].z);
                        endShape(CLOSE);
                    }
                }
            }

            v = [];
        }

        function windowResized() {
            resizeCanvas(windowWidth, windowHeight);
            
            // 重新计算缩放因子
            scaleFactor = min(windowWidth, windowHeight) / 1000;
            
            // 更新文字位置边界
            const maxX = windowWidth - textElement.offsetWidth;
            const maxY = windowHeight - textElement.offsetHeight;
            textX = constrain(textX, 0, maxX);
            textY = constrain(textY, 0, maxY);
            updateTextPosition();
        }
    </script>
</body>
</html>
